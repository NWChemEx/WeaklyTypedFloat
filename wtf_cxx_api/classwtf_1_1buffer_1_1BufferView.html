<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>wtf: wtf::buffer::BufferView&lt; FloatType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">wtf<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacewtf.html">wtf</a></li><li class="navelem"><a class="el" href="namespacewtf_1_1buffer.html">buffer</a></li><li class="navelem"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classwtf_1_1buffer_1_1BufferView-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">wtf::buffer::BufferView&lt; FloatType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A type-erased buffer of floating-point values.  
 <a href="classwtf_1_1buffer_1_1BufferView.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buffer__view_8hpp_source.html">buffer_view.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab636f927b98b86d9297db0820cf7e1d8" id="r_ab636f927b98b86d9297db0820cf7e1d8"><td class="memItemLeft" align="right" valign="top"><a id="ab636f927b98b86d9297db0820cf7e1d8" name="ab636f927b98b86d9297db0820cf7e1d8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>holder_type</b> = <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferViewHolder.html">detail_::BufferViewHolder</a>&lt; apply_const_t&lt; FloatType &gt; &gt;</td></tr>
<tr class="memdesc:ab636f927b98b86d9297db0820cf7e1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type defining the API for accessing the type-erased value. <br /></td></tr>
<tr class="separator:ab636f927b98b86d9297db0820cf7e1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6f963e81089abd32f8d19ad497036df7" id="r_a6f963e81089abd32f8d19ad497036df7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a6f963e81089abd32f8d19ad497036df7">holder_pointer</a> = typename <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferViewHolder.html#a0e68c2e21af7d9e37064483e9d2b3d25">holder_type::holder_pointer</a></td></tr>
<tr class="separator:a6f963e81089abd32f8d19ad497036df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e11453155ac6b8f3d584dbb450be4f0" id="r_a9e11453155ac6b8f3d584dbb450be4f0"><td class="memItemLeft" align="right" valign="top"><a id="a9e11453155ac6b8f3d584dbb450be4f0" name="a9e11453155ac6b8f3d584dbb450be4f0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferViewHolder.html#adc995cbde925a727bc79bef63b5dad82">holder_type::size_type</a></td></tr>
<tr class="separator:a9e11453155ac6b8f3d584dbb450be4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a51f7df9d6326a3c0fd97ed7959b19" id="r_a59a51f7df9d6326a3c0fd97ed7959b19"><td class="memItemLeft" align="right" valign="top"><a id="a59a51f7df9d6326a3c0fd97ed7959b19" name="a59a51f7df9d6326a3c0fd97ed7959b19"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>view_type</b> = typename <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferViewHolder.html#afc5b949c283b1c6a74a917ed4b3433a4">holder_type::view_type</a></td></tr>
<tr class="separator:a59a51f7df9d6326a3c0fd97ed7959b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69009eace52128aeb53b1f0e24e135f" id="r_ac69009eace52128aeb53b1f0e24e135f"><td class="memItemLeft" align="right" valign="top"><a id="ac69009eace52128aeb53b1f0e24e135f" name="ac69009eace52128aeb53b1f0e24e135f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_view_type</b> = typename <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferViewHolder.html#adf5c9b84b54620e4ece30cd603e9f341">holder_type::const_view_type</a></td></tr>
<tr class="separator:ac69009eace52128aeb53b1f0e24e135f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aac69a225713096bf7afc3be617eb11bd" id="r_aac69a225713096bf7afc3be617eb11bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#aac69a225713096bf7afc3be617eb11bd">BufferView</a> () noexcept</td></tr>
<tr class="memdesc:aac69a225713096bf7afc3be617eb11bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of a null buffer.  <br /></td></tr>
<tr class="separator:aac69a225713096bf7afc3be617eb11bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46edd493946bd0e56c54ae63d186a98" id="r_af46edd493946bd0e56c54ae63d186a98"><td class="memTemplParams" colspan="2">template&lt;typename BufferType2 &gt; <br />
requires (concepts::FloatBuffer&lt;std::remove_reference_t&lt;BufferType2&gt;&gt;)</td></tr>
<tr class="memitem:af46edd493946bd0e56c54ae63d186a98"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#af46edd493946bd0e56c54ae63d186a98">BufferView</a> (BufferType2 &amp;&amp;buffer)</td></tr>
<tr class="memdesc:af46edd493946bd0e56c54ae63d186a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicitly converts <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> to <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a>.  <br /></td></tr>
<tr class="separator:af46edd493946bd0e56c54ae63d186a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c1d4279fbb1f2141f6908e694051e7" id="r_a23c1d4279fbb1f2141f6908e694051e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires (concepts::FloatingPoint&lt;T&gt;)</td></tr>
<tr class="memitem:a23c1d4279fbb1f2141f6908e694051e7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a23c1d4279fbb1f2141f6908e694051e7">BufferView</a> (T *pbuffer, size_type <a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a95a40c8ba2517da02f61160a18508ad8">size</a>)</td></tr>
<tr class="memdesc:a23c1d4279fbb1f2141f6908e694051e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> from an existing buffer.  <br /></td></tr>
<tr class="separator:a23c1d4279fbb1f2141f6908e694051e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac834f2c4bf6e4017d5f3fb21911b0461" id="r_ac834f2c4bf6e4017d5f3fb21911b0461"><td class="memItemLeft" align="right" valign="top"><a id="ac834f2c4bf6e4017d5f3fb21911b0461" name="ac834f2c4bf6e4017d5f3fb21911b0461"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BufferView</b> (<a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a6f963e81089abd32f8d19ad497036df7">holder_pointer</a> pholder)</td></tr>
<tr class="memdesc:ac834f2c4bf6e4017d5f3fb21911b0461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Other ctors create the holder and then dispatch to this ctor. <br /></td></tr>
<tr class="separator:ac834f2c4bf6e4017d5f3fb21911b0461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad5505ca90a84eb13f069509f48f939" id="r_a7ad5505ca90a84eb13f069509f48f939"><td class="memTemplParams" colspan="2">template&lt;concepts::WTFFloat OtherFloat&gt; <br />
requires (is_const &amp;&amp; !concepts::ConstQualified&lt;OtherFloat&gt;)</td></tr>
<tr class="memitem:a7ad5505ca90a84eb13f069509f48f939"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a7ad5505ca90a84eb13f069509f48f939">BufferView</a> (const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; OtherFloat &gt; &amp;other)</td></tr>
<tr class="memdesc:a7ad5505ca90a84eb13f069509f48f939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from mutable alias to a read-only alias.  <br /></td></tr>
<tr class="separator:a7ad5505ca90a84eb13f069509f48f939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99538c181e58e3368be6e9287792b93" id="r_ae99538c181e58e3368be6e9287792b93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#ae99538c181e58e3368be6e9287792b93">BufferView</a> (const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a> &amp;other)</td></tr>
<tr class="memdesc:ae99538c181e58e3368be6e9287792b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> as a copy of <code>other</code>.  <br /></td></tr>
<tr class="separator:ae99538c181e58e3368be6e9287792b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a11c13d9049bbb44e33cb721b26254" id="r_a24a11c13d9049bbb44e33cb721b26254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a24a11c13d9049bbb44e33cb721b26254">operator=</a> (const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a> &amp;other)</td></tr>
<tr class="memdesc:a24a11c13d9049bbb44e33cb721b26254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides the state of *this with a shallow copy of <code>other</code>.  <br /></td></tr>
<tr class="separator:a24a11c13d9049bbb44e33cb721b26254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266a4aa9ba1f0c1883bbe7ff4f76ae5d" id="r_a266a4aa9ba1f0c1883bbe7ff4f76ae5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a266a4aa9ba1f0c1883bbe7ff4f76ae5d">BufferView</a> (<a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a266a4aa9ba1f0c1883bbe7ff4f76ae5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> by taking the state from <code>other</code>.  <br /></td></tr>
<tr class="separator:a266a4aa9ba1f0c1883bbe7ff4f76ae5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8d45fee8d3ce2e1c5eef77899c1566" id="r_a3b8d45fee8d3ce2e1c5eef77899c1566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a3b8d45fee8d3ce2e1c5eef77899c1566">operator=</a> (<a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a3b8d45fee8d3ce2e1c5eef77899c1566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides the state of *this with the state in <code>other</code>.  <br /></td></tr>
<tr class="separator:a3b8d45fee8d3ce2e1c5eef77899c1566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dff25c4d690d75b331e5567210e03e3" id="r_a1dff25c4d690d75b331e5567210e03e3"><td class="memItemLeft" align="right" valign="top">view_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a1dff25c4d690d75b331e5567210e03e3">at</a> (size_type index)</td></tr>
<tr class="memdesc:a1dff25c4d690d75b331e5567210e03e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element with offset <code>index</code>.  <br /></td></tr>
<tr class="separator:a1dff25c4d690d75b331e5567210e03e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ee67514782efaa922eb1ff26e781c0" id="r_aa1ee67514782efaa922eb1ff26e781c0"><td class="memItemLeft" align="right" valign="top">const_view_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#aa1ee67514782efaa922eb1ff26e781c0">at</a> (size_type index) const</td></tr>
<tr class="memdesc:aa1ee67514782efaa922eb1ff26e781c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element with offset <code>index</code>.  <br /></td></tr>
<tr class="separator:aa1ee67514782efaa922eb1ff26e781c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a40c8ba2517da02f61160a18508ad8" id="r_a95a40c8ba2517da02f61160a18508ad8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a95a40c8ba2517da02f61160a18508ad8">size</a> () const noexcept</td></tr>
<tr class="memdesc:a95a40c8ba2517da02f61160a18508ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the buffer.  <br /></td></tr>
<tr class="separator:a95a40c8ba2517da02f61160a18508ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03322c2b371c4f90fcc2dd226bd10762" id="r_a03322c2b371c4f90fcc2dd226bd10762"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a03322c2b371c4f90fcc2dd226bd10762">is_contiguous</a> () const</td></tr>
<tr class="memdesc:a03322c2b371c4f90fcc2dd226bd10762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the held buffer store the values contiguously?  <br /></td></tr>
<tr class="separator:a03322c2b371c4f90fcc2dd226bd10762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b7f1781087136b0e28671f7380411f" id="r_a17b7f1781087136b0e28671f7380411f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a17b7f1781087136b0e28671f7380411f">operator==</a> (const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a> &amp;other) const</td></tr>
<tr class="memdesc:a17b7f1781087136b0e28671f7380411f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is value equal to <code>other</code>.  <br /></td></tr>
<tr class="separator:a17b7f1781087136b0e28671f7380411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f27c93af5727313d3e1c919b594e033" id="r_a8f27c93af5727313d3e1c919b594e033"><td class="memTemplParams" colspan="2">template&lt;concepts::WTFFloat OtherFloat&gt; <br />
requires (!std::is_same_v&lt;OtherFloat, FloatType&gt;)</td></tr>
<tr class="memitem:a8f27c93af5727313d3e1c919b594e033"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a8f27c93af5727313d3e1c919b594e033">operator==</a> (const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; OtherFloat &gt; &amp;other) const</td></tr>
<tr class="memdesc:a8f27c93af5727313d3e1c919b594e033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is value equal to <code>other</code>.  <br /></td></tr>
<tr class="separator:a8f27c93af5727313d3e1c919b594e033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad225b186743f069be5556ceeb44c308d" id="r_ad225b186743f069be5556ceeb44c308d"><td class="memTemplParams" colspan="2">template&lt;concepts::WTFFloat OtherFloat&gt; </td></tr>
<tr class="memitem:ad225b186743f069be5556ceeb44c308d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#ad225b186743f069be5556ceeb44c308d">operator!=</a> (const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; OtherFloat &gt; &amp;other) const</td></tr>
<tr class="memdesc:ad225b186743f069be5556ceeb44c308d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this buffer different from <code>other</code>?  <br /></td></tr>
<tr class="separator:ad225b186743f069be5556ceeb44c308d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08714bfc60ddd34bb805f1ef1ea0571" id="r_ae08714bfc60ddd34bb805f1ef1ea0571"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae08714bfc60ddd34bb805f1ef1ea0571"><td class="memTemplItemLeft" align="right" valign="top">std::span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#ae08714bfc60ddd34bb805f1ef1ea0571">value</a> ()</td></tr>
<tr class="memdesc:ae08714bfc60ddd34bb805f1ef1ea0571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to access the buffer.  <br /></td></tr>
<tr class="separator:ae08714bfc60ddd34bb805f1ef1ea0571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac8a76321b50114c05310e4b60e287d" id="r_a3ac8a76321b50114c05310e4b60e287d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ac8a76321b50114c05310e4b60e287d"><td class="memTemplItemLeft" align="right" valign="top">std::span&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a3ac8a76321b50114c05310e4b60e287d">value</a> () const</td></tr>
<tr class="memdesc:a3ac8a76321b50114c05310e4b60e287d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to access the buffer.  <br /></td></tr>
<tr class="separator:a3ac8a76321b50114c05310e4b60e287d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a742e865aabb928a6da1e634a2a069a03" id="r_a742e865aabb928a6da1e634a2a069a03"><td class="memTemplParams" colspan="2"><a id="a742e865aabb928a6da1e634a2a069a03" name="a742e865aabb928a6da1e634a2a069a03"></a>
template&lt;typename TupleType , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:a742e865aabb928a6da1e634a2a069a03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_contiguous_buffer_view</b> (Visitor &amp;&amp;visitor, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a742e865aabb928a6da1e634a2a069a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a87e5721b8e495025eb550e850a4d1d1e" id="r_a87e5721b8e495025eb550e850a4d1d1e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a87e5721b8e495025eb550e850a4d1d1e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a87e5721b8e495025eb550e850a4d1d1e">make_buffer_view</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a87e5721b8e495025eb550e850a4d1d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps calling the <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> ctor.  <br /></td></tr>
<tr class="separator:a87e5721b8e495025eb550e850a4d1d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14553f1bad7e07d73b6a1d1679e214d" id="r_aa14553f1bad7e07d73b6a1d1679e214d"><td class="memTemplParams" colspan="2">template&lt;concepts::FloatingPoint T, concepts::WTFFloat FloatType&gt; </td></tr>
<tr class="memitem:aa14553f1bad7e07d73b6a1d1679e214d"><td class="memTemplItemLeft" align="right" valign="top">std::span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#aa14553f1bad7e07d73b6a1d1679e214d">contiguous_buffer_cast</a> (<a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; FloatType &gt; &amp;buffer)</td></tr>
<tr class="memdesc:aa14553f1bad7e07d73b6a1d1679e214d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to retrieve the raw contiguous memory from a buffer view.  <br /></td></tr>
<tr class="separator:aa14553f1bad7e07d73b6a1d1679e214d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742e865aabb928a6da1e634a2a069a03" id="r_a742e865aabb928a6da1e634a2a069a03"><td class="memTemplParams" colspan="2">template&lt;typename TupleType , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:a742e865aabb928a6da1e634a2a069a03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a742e865aabb928a6da1e634a2a069a03">visit_contiguous_buffer_view</a> (Visitor &amp;&amp;visitor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a742e865aabb928a6da1e634a2a069a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the process of calling a visitor with zero or more <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> objects.  <br /></td></tr>
<tr class="separator:a742e865aabb928a6da1e634a2a069a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;concepts::WTFFloat FloatType&gt;<br />
class wtf::buffer::BufferView&lt; FloatType &gt;</div><p>A type-erased buffer of floating-point values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FloatType</td><td>The type of the elements in the buffer. Must satisfy the concepts::WTFFloat concept.</td></tr>
  </table>
  </dd>
</dl>
<p>This class aliases an existing buffer and allows the user to interact with it as if it were a <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> object. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6f963e81089abd32f8d19ad497036df7" name="a6f963e81089abd32f8d19ad497036df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f963e81089abd32f8d19ad497036df7">&#9670;&#160;</a></span>holder_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::holder_pointer =  typename <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferViewHolder.html#a0e68c2e21af7d9e37064483e9d2b3d25">holder_type::holder_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pull in types from the holder_type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aac69a225713096bf7afc3be617eb11bd" name="aac69a225713096bf7afc3be617eb11bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac69a225713096bf7afc3be617eb11bd">&#9670;&#160;</a></span>BufferView() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::BufferView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view of a null buffer. </p>
<p>A null buffer has zero elements and can not be accessed. This ctor is used to create a null buffer.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No-throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af46edd493946bd0e56c54ae63d186a98" name="af46edd493946bd0e56c54ae63d186a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46edd493946bd0e56c54ae63d186a98">&#9670;&#160;</a></span>BufferView() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<div class="memtemplate">
template&lt;typename BufferType2 &gt; <br />
requires (concepts::FloatBuffer&lt;std::remove_reference_t&lt;BufferType2&gt;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::BufferView </td>
          <td>(</td>
          <td class="paramtype">BufferType2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicitly converts <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> to <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BufferType2</td><td>The type of the buffer being converted from. Must satisfy the concept <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This ctor is used to implicitly convert <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> objects into <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer to convert from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocating the holder fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23c1d4279fbb1f2141f6908e694051e7" name="a23c1d4279fbb1f2141f6908e694051e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c1d4279fbb1f2141f6908e694051e7">&#9670;&#160;</a></span>BufferView() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires (concepts::FloatingPoint&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::BufferView </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> from an existing buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of floating-point value being held. Must satisfy the concepts::FloatingPoint concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pbuffer</td><td>A pointer to the first element in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocating the holder fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ad5505ca90a84eb13f069509f48f939" name="a7ad5505ca90a84eb13f069509f48f939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad5505ca90a84eb13f069509f48f939">&#9670;&#160;</a></span>BufferView() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<div class="memtemplate">
template&lt;concepts::WTFFloat OtherFloat&gt; <br />
requires (is_const &amp;&amp; !concepts::ConstQualified&lt;OtherFloat&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::BufferView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; OtherFloat &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion from mutable alias to a read-only alias. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherFloat</td><td>The type of floating-point value being held in <code>other</code>. Must satisfy the concepts::WTFFloat concept.</td></tr>
  </table>
  </dd>
</dl>
<p>This ctor enables implicit conversion from a BufferView&lt;fp::Float&gt; to BufferView&lt;const fp::Float&gt;.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocating the holder fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae99538c181e58e3368be6e9287792b93" name="ae99538c181e58e3368be6e9287792b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99538c181e58e3368be6e9287792b93">&#9670;&#160;</a></span>BufferView() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::BufferView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; FloatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> as a copy of <code>other</code>. </p>
<p>This ctor will initialize *this to hold a shallow copy of <code>other</code>. Here "shallow" means that *this will alias the same buffer as <code>other</code>. Note that *this will NOT alias <code>other</code> itself, i.e., modifying the what *this aliases will not modify what <code>other</code> aliases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if copying the held buffer fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a266a4aa9ba1f0c1883bbe7ff4f76ae5d" name="a266a4aa9ba1f0c1883bbe7ff4f76ae5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266a4aa9ba1f0c1883bbe7ff4f76ae5d">&#9670;&#160;</a></span>BufferView() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::BufferView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; FloatType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> by taking the state from <code>other</code>. </p>
<p>This ctor will initialize *this by taking ownership of the state in <code>other</code>. After the operation <code>other</code> is in a valid but unspecified state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> to move from. After the operation <code>other</code> is in a valid but unspecified state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1dff25c4d690d75b331e5567210e03e3" name="a1dff25c4d690d75b331e5567210e03e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dff25c4d690d75b331e5567210e03e3">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">view_type <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element with offset <code>index</code>. </p>
<p>This method is used to retrieve an element of the buffer. The returned element aliases the buffer, meaning that you can write to the buffer through the element. While float_cast can be used to ge the address in the buffer (by casting to a reference), users should use <code>contiguous_buffer_cast</code> to get a span if they need to get the pointer (and ensure the underlying memory really is contiguous).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view to the element at offset <code>index</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>index</code> is not less than <a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a95a40c8ba2517da02f61160a18508ad8" title="Returns the number of elements in the buffer.">size()</a>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1ee67514782efaa922eb1ff26e781c0" name="aa1ee67514782efaa922eb1ff26e781c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ee67514782efaa922eb1ff26e781c0">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_view_type <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element with offset <code>index</code>. </p>
<p>This method is the same as the non-const version, but returns a read- only view of the element. See the non-const version for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const view to the element at offset <code>index</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>index</code> is not less than <a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a95a40c8ba2517da02f61160a18508ad8" title="Returns the number of elements in the buffer.">size()</a>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03322c2b371c4f90fcc2dd226bd10762" name="a03322c2b371c4f90fcc2dd226bd10762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03322c2b371c4f90fcc2dd226bd10762">&#9670;&#160;</a></span>is_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::is_contiguous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the held buffer store the values contiguously? </p>
<p>Given a pointer to one element in the buffer, if the elements of the buffer are contiguous then pointer arithmetic may be used to access the other elements. If the buffer is not contiguous then the only way to access the elements is through the <a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a1dff25c4d690d75b331e5567210e03e3" title="Returns the element with offset index.">at()</a> method. Attempting to treat a non-contiguous buffer as contiguous will lead to undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the held buffer is contiguous, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad225b186743f069be5556ceeb44c308d" name="ad225b186743f069be5556ceeb44c308d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad225b186743f069be5556ceeb44c308d">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<div class="memtemplate">
template&lt;concepts::WTFFloat OtherFloat&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; OtherFloat &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this buffer different from <code>other</code>? </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherFloat</td><td>The type of floating-point value being held in <code>other</code>. Must satisfy the concepts::WTFFloat concept.</td></tr>
  </table>
  </dd>
</dl>
<p>Two <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> objects are different if they are not value equal. Thus this method simply negates the result of operator==. See that method for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if *this and <code>other</code> are different, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b8d45fee8d3ce2e1c5eef77899c1566" name="a3b8d45fee8d3ce2e1c5eef77899c1566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8d45fee8d3ce2e1c5eef77899c1566">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a> &amp; <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; FloatType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides the state of *this with the state in <code>other</code>. </p>
<p>This operator is the same as the move ctor, except that the move will override the state in *this instead of initializing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> to move from. After the operation <code>other</code> is in a valid but unspecified state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24a11c13d9049bbb44e33cb721b26254" name="a24a11c13d9049bbb44e33cb721b26254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a11c13d9049bbb44e33cb721b26254">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a> &amp; <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; FloatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides the state of *this with a shallow copy of <code>other</code>. </p>
<p>This operator is similar to the copy ctor, except that the copy is being assigned to a pre-existing <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a>. The state in *this will be overridden by a shallow copy of <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if copying the held buffer fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17b7f1781087136b0e28671f7380411f" name="a17b7f1781087136b0e28671f7380411f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b7f1781087136b0e28671f7380411f">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; FloatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is value equal to <code>other</code>. </p>
<p>Two <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> objects are value equal if they hold the same number of elements, if those elements are of the same type, and if the corresponding elements compare equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if *this and <code>other</code> are value equal, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f27c93af5727313d3e1c919b594e033" name="a8f27c93af5727313d3e1c919b594e033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f27c93af5727313d3e1c919b594e033">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<div class="memtemplate">
template&lt;concepts::WTFFloat OtherFloat&gt; <br />
requires (!std::is_same_v&lt;OtherFloat, FloatType&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; OtherFloat &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is value equal to <code>other</code>. </p>
<p>This overload allows comparison between <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> objects that alias buffers of different const-ness. See the other operator== for details on what value equality means. The actual comparison is done by converting both *this and <code>other</code> to const holders and then comparing those.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if *this and <code>other</code> are value equal, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if allocating the temporary holder fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95a40c8ba2517da02f61160a18508ad8" name="a95a40c8ba2517da02f61160a18508ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a40c8ba2517da02f61160a18508ad8">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the buffer. </p>
<p>This method is used to retrieve the number of elements in the buffer. Since the buffer is zero-indexed, valid indices for <a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a1dff25c4d690d75b331e5567210e03e3" title="Returns the element with offset index.">at()</a> are in the range [0, <a class="el" href="classwtf_1_1buffer_1_1BufferView.html#a95a40c8ba2517da02f61160a18508ad8" title="Returns the number of elements in the buffer.">size()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae08714bfc60ddd34bb805f1ef1ea0571" name="ae08714bfc60ddd34bb805f1ef1ea0571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08714bfc60ddd34bb805f1ef1ea0571">&#9670;&#160;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; T &gt; <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to access the buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of floating-point value being held. Must satisfy the concepts::FloatingPoint concept.</td></tr>
  </table>
  </dd>
</dl>
<p>Users are encouraged to use <code>contiguous_buffer_cast</code> instead of this method. This method is exposed to facilitate implementing that function.</p>
<dl class="section return"><dt>Returns</dt><dd>A span aliasing the held buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the held buffer is not of type T. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ac8a76321b50114c05310e4b60e287d" name="a3ac8a76321b50114c05310e4b60e287d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac8a76321b50114c05310e4b60e287d">&#9670;&#160;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::WTFFloat FloatType&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; const T &gt; <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">wtf::buffer::BufferView</a>&lt; FloatType &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to access the buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of floating-point value being held. Must satisfy the concepts::FloatingPoint concept.</td></tr>
  </table>
  </dd>
</dl>
<p>This method is the same as the non-const version, but returns a read- only span. Users are encouraged to use <code>contiguous_buffer_cast</code> instead of this method. This method is exposed to facilitate implementing that function.</p>
<dl class="section return"><dt>Returns</dt><dd>A const span aliasing the held buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the held buffer is not of type T. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aa14553f1bad7e07d73b6a1d1679e214d" name="aa14553f1bad7e07d73b6a1d1679e214d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14553f1bad7e07d73b6a1d1679e214d">&#9670;&#160;</a></span>contiguous_buffer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::FloatingPoint T, concepts::WTFFloat FloatType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; T &gt; contiguous_buffer_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; FloatType &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to retrieve the raw contiguous memory from a buffer view. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of floating-point value being held. Must satisfy the concepts::FloatingPoint concept. The user must explicitly provide this template type parameter. </td></tr>
    <tr><td class="paramname">FloatType</td><td>The type of buffer the <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> is acting like. Must satisfy the concepts::WTFFloat concept. The compiler will deduce this parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is the preferred way to get the typed contiguous memory back from a <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a>. It will check that the held buffer is contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> to get the contiguous memory from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A span aliasing the contiguous memory held by <code>buffer</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the held buffer is not contiguous. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the held buffer is not of type T. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87e5721b8e495025eb550e850a4d1d1e" name="a87e5721b8e495025eb550e850a4d1d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e5721b8e495025eb550e850a4d1d1e">&#9670;&#160;</a></span>make_buffer_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto make_buffer_view </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps calling the <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> ctor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>The types of the arguments to forward to the <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> ctor.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is only provided so that <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> can be created by analogy to other type-erased objects like std::any, Float, and FloatView.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The arguments to forward to the <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> ctor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> constructed with the forwarded arguments. </dd></dl>

</div>
</div>
<a id="a742e865aabb928a6da1e634a2a069a03" name="a742e865aabb928a6da1e634a2a069a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742e865aabb928a6da1e634a2a069a03">&#9670;&#160;</a></span>visit_contiguous_buffer_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType , typename Visitor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto visit_contiguous_buffer_view </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the process of calling a visitor with zero or more <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TupleType</td><td>A std::tuple of floating-point types to try. Must be explicitly provided by the user. </td></tr>
    <tr><td class="paramname">Visitor</td><td>The type of the visitor to call. Must be a callable object capable of accepting <code>std::span&lt;T&gt;</code> objects for each possible T in <code>TupleType</code>. Will be inferred by the compiler. </td></tr>
    <tr><td class="paramname">Args</td><td>The types of the arguments to forward to the visitor. Each is expected to be downcastable to a ContiguousModel holding one of the types in <code>TupleType</code>. Will be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">visitor</td><td>The visitor to call with the unwrapped std::span&lt;T&gt; objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The ContiguousModel objects to unwrap and pass to the visitor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of calling <code>visitor</code> with the unwrapped std::span&lt;T&gt; objects.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if any of the <code>args</code> cannot be downcast to a ContiguousModel holding one of the types in <code>TupleType</code>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>if calling <code>visitor</code> throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/wtf/buffer/<a class="el" href="buffer__view_8hpp_source.html">buffer_view.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
