<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>wtf: wtf::buffer::FloatBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">wtf<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacewtf.html">wtf</a></li><li class="navelem"><a class="el" href="namespacewtf_1_1buffer.html">buffer</a></li><li class="navelem"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Symbols</a> &#124;
<a href="classwtf_1_1buffer_1_1FloatBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">wtf::buffer::FloatBuffer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A type-erased buffer of floating-point values.  
 <a href="classwtf_1_1buffer_1_1FloatBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buffer_2float__buffer_8hpp_source.html">float_buffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a80ed37c2637d98388e48a0736eb1695b" id="r_a80ed37c2637d98388e48a0736eb1695b"><td class="memItemLeft" align="right" valign="top"><a id="a80ed37c2637d98388e48a0736eb1695b" name="a80ed37c2637d98388e48a0736eb1695b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>holder_type</b> = <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferHolder.html">detail_::BufferHolder</a></td></tr>
<tr class="memdesc:a80ed37c2637d98388e48a0736eb1695b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type defining the API for accessing the type-erased value. <br /></td></tr>
<tr class="separator:a80ed37c2637d98388e48a0736eb1695b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc168949fed27e33bd7387f37b57397" id="r_a7cc168949fed27e33bd7387f37b57397"><td class="memItemLeft" align="right" valign="top"><a id="a7cc168949fed27e33bd7387f37b57397" name="a7cc168949fed27e33bd7387f37b57397"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_view</b> = <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; value_type &gt;</td></tr>
<tr class="separator:a7cc168949fed27e33bd7387f37b57397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecf60eefdee3dec6e82765897268097" id="r_a5ecf60eefdee3dec6e82765897268097"><td class="memItemLeft" align="right" valign="top"><a id="a5ecf60eefdee3dec6e82765897268097" name="a5ecf60eefdee3dec6e82765897268097"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_buffer_view</b> = <a class="el" href="classwtf_1_1buffer_1_1BufferView.html">BufferView</a>&lt; const value_type &gt;</td></tr>
<tr class="separator:a5ecf60eefdee3dec6e82765897268097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a33ae684e80d7ae56007efd7066f7a087" id="r_a33ae684e80d7ae56007efd7066f7a087"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a33ae684e80d7ae56007efd7066f7a087">holder_pointer</a> = typename <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferHolder.html#af6da0f90639b3ff4462098c267c5ec6f">holder_type::holder_pointer</a></td></tr>
<tr class="separator:a33ae684e80d7ae56007efd7066f7a087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97ae39a7ab6abee1579dc8078782cb6" id="r_af97ae39a7ab6abee1579dc8078782cb6"><td class="memItemLeft" align="right" valign="top"><a id="af97ae39a7ab6abee1579dc8078782cb6" name="af97ae39a7ab6abee1579dc8078782cb6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = typename <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferHolder.html#aba7be624500c75abd99bf5c25a6b22b7">holder_type::value_type</a></td></tr>
<tr class="separator:af97ae39a7ab6abee1579dc8078782cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59ccebfff444b63d1dfa8c8e4c3c2d3" id="r_aa59ccebfff444b63d1dfa8c8e4c3c2d3"><td class="memItemLeft" align="right" valign="top"><a id="aa59ccebfff444b63d1dfa8c8e4c3c2d3" name="aa59ccebfff444b63d1dfa8c8e4c3c2d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferHolder.html#a049b31cff676c3cf6d23f2f8f3df2395">holder_type::size_type</a></td></tr>
<tr class="separator:aa59ccebfff444b63d1dfa8c8e4c3c2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edc08a1181acdb1fcd5c30ff67ce355" id="r_a8edc08a1181acdb1fcd5c30ff67ce355"><td class="memItemLeft" align="right" valign="top"><a id="a8edc08a1181acdb1fcd5c30ff67ce355" name="a8edc08a1181acdb1fcd5c30ff67ce355"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>view_type</b> = typename <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferHolder.html#ad0a34dddb20c5ccb77b05daea204463d">holder_type::view_type</a></td></tr>
<tr class="separator:a8edc08a1181acdb1fcd5c30ff67ce355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fd0ce002cdc7af40da1c81631d5358" id="r_a58fd0ce002cdc7af40da1c81631d5358"><td class="memItemLeft" align="right" valign="top"><a id="a58fd0ce002cdc7af40da1c81631d5358" name="a58fd0ce002cdc7af40da1c81631d5358"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_view_type</b> = typename <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferHolder.html#a4c7c8f0d1d017a3f0911025f6cbfaf2d">holder_type::const_view_type</a></td></tr>
<tr class="separator:a58fd0ce002cdc7af40da1c81631d5358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc62a8eb534601e52ce5873aae4979c2" id="r_afc62a8eb534601e52ce5873aae4979c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#afc62a8eb534601e52ce5873aae4979c2">FloatBuffer</a> () noexcept=default</td></tr>
<tr class="memdesc:afc62a8eb534601e52ce5873aae4979c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty buffer.  <br /></td></tr>
<tr class="separator:afc62a8eb534601e52ce5873aae4979c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13902e3c35e78c18c35dbcc01e606c3" id="r_ad13902e3c35e78c18c35dbcc01e606c3"><td class="memTemplParams" colspan="2">template&lt;concepts::FloatingPoint T&gt; </td></tr>
<tr class="memitem:ad13902e3c35e78c18c35dbcc01e606c3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#ad13902e3c35e78c18c35dbcc01e606c3">FloatBuffer</a> (std::initializer_list&lt; T &gt; buffer)</td></tr>
<tr class="memdesc:ad13902e3c35e78c18c35dbcc01e606c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> from a list of specified values.  <br /></td></tr>
<tr class="separator:ad13902e3c35e78c18c35dbcc01e606c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59eb74acdf2db8afe431a5bf0481f509" id="r_a59eb74acdf2db8afe431a5bf0481f509"><td class="memTemplParams" colspan="2">template&lt;concepts::FloatingPoint T&gt; </td></tr>
<tr class="memitem:a59eb74acdf2db8afe431a5bf0481f509"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a59eb74acdf2db8afe431a5bf0481f509">FloatBuffer</a> (std::vector&lt; T &gt; buffer)</td></tr>
<tr class="memdesc:a59eb74acdf2db8afe431a5bf0481f509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> from a std::vector.  <br /></td></tr>
<tr class="separator:a59eb74acdf2db8afe431a5bf0481f509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfc18b2a1d3ff20aca110b8b448e6d8" id="r_a7cfc18b2a1d3ff20aca110b8b448e6d8"><td class="memTemplParams" colspan="2">template&lt;concepts::FPIterator BeginItr, concepts::FPIterator EndItr&gt; </td></tr>
<tr class="memitem:a7cfc18b2a1d3ff20aca110b8b448e6d8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a7cfc18b2a1d3ff20aca110b8b448e6d8">FloatBuffer</a> (BeginItr &amp;&amp;begin, EndItr &amp;&amp;end)</td></tr>
<tr class="memdesc:a7cfc18b2a1d3ff20aca110b8b448e6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> from a range of iterators.  <br /></td></tr>
<tr class="separator:a7cfc18b2a1d3ff20aca110b8b448e6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12aa995db0ed62b437bf81bfae980263" id="r_a12aa995db0ed62b437bf81bfae980263"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a12aa995db0ed62b437bf81bfae980263">FloatBuffer</a> (const <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;other)</td></tr>
<tr class="memdesc:a12aa995db0ed62b437bf81bfae980263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> as a copy of <code>other</code>.  <br /></td></tr>
<tr class="separator:a12aa995db0ed62b437bf81bfae980263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8830755b14fdcea4d0b742be31953569" id="r_a8830755b14fdcea4d0b742be31953569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a8830755b14fdcea4d0b742be31953569">operator=</a> (const <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;other)</td></tr>
<tr class="memdesc:a8830755b14fdcea4d0b742be31953569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides the state of *this with a deep copy of <code>other</code>.  <br /></td></tr>
<tr class="separator:a8830755b14fdcea4d0b742be31953569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c763c97ca7ae1bae432255d6436462f" id="r_a0c763c97ca7ae1bae432255d6436462f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a0c763c97ca7ae1bae432255d6436462f">FloatBuffer</a> (<a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a0c763c97ca7ae1bae432255d6436462f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> by taking the state from <code>other</code>.  <br /></td></tr>
<tr class="separator:a0c763c97ca7ae1bae432255d6436462f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6375aa4f57ea7404ffcb6c8bbe430c" id="r_ade6375aa4f57ea7404ffcb6c8bbe430c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#ade6375aa4f57ea7404ffcb6c8bbe430c">operator=</a> (<a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:ade6375aa4f57ea7404ffcb6c8bbe430c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides the state of *this with the state in <code>other</code>.  <br /></td></tr>
<tr class="separator:ade6375aa4f57ea7404ffcb6c8bbe430c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164cb24d3bcc20a80761edde8ea90e6e" id="r_a164cb24d3bcc20a80761edde8ea90e6e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a164cb24d3bcc20a80761edde8ea90e6e">as_view</a> ()</td></tr>
<tr class="memdesc:a164cb24d3bcc20a80761edde8ea90e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly converts *this into a <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a>.  <br /></td></tr>
<tr class="separator:a164cb24d3bcc20a80761edde8ea90e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002c06fc30fca256a1b280f9e9a0f0ea" id="r_a002c06fc30fca256a1b280f9e9a0f0ea"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a002c06fc30fca256a1b280f9e9a0f0ea">as_view</a> () const</td></tr>
<tr class="memdesc:a002c06fc30fca256a1b280f9e9a0f0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly converts *this into a <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a>.  <br /></td></tr>
<tr class="separator:a002c06fc30fca256a1b280f9e9a0f0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79439d94db5eea1d58d16c5f54669929" id="r_a79439d94db5eea1d58d16c5f54669929"><td class="memItemLeft" align="right" valign="top">view_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a79439d94db5eea1d58d16c5f54669929">at</a> (size_type index)</td></tr>
<tr class="memdesc:a79439d94db5eea1d58d16c5f54669929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element with offset <code>index</code>.  <br /></td></tr>
<tr class="separator:a79439d94db5eea1d58d16c5f54669929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407663baaba19635328c674d5eea104b" id="r_a407663baaba19635328c674d5eea104b"><td class="memItemLeft" align="right" valign="top">const_view_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a407663baaba19635328c674d5eea104b">at</a> (size_type index) const</td></tr>
<tr class="memdesc:a407663baaba19635328c674d5eea104b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element with offset <code>index</code>.  <br /></td></tr>
<tr class="separator:a407663baaba19635328c674d5eea104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d452340ab895507bc0d315bafdaeb1" id="r_af4d452340ab895507bc0d315bafdaeb1"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#af4d452340ab895507bc0d315bafdaeb1">size</a> () const noexcept</td></tr>
<tr class="memdesc:af4d452340ab895507bc0d315bafdaeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the buffer.  <br /></td></tr>
<tr class="separator:af4d452340ab895507bc0d315bafdaeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7282e501eb469c92e94864586fa7262" id="r_ac7282e501eb469c92e94864586fa7262"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#ac7282e501eb469c92e94864586fa7262">is_contiguous</a> () const</td></tr>
<tr class="memdesc:ac7282e501eb469c92e94864586fa7262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the held buffer store the values contiguously?  <br /></td></tr>
<tr class="separator:ac7282e501eb469c92e94864586fa7262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695f2bdcbdcd5772ba203c4e1a56686c" id="r_a695f2bdcbdcd5772ba203c4e1a56686c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a695f2bdcbdcd5772ba203c4e1a56686c">operator==</a> (const <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;other) const</td></tr>
<tr class="memdesc:a695f2bdcbdcd5772ba203c4e1a56686c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is value equal to <code>other</code>.  <br /></td></tr>
<tr class="separator:a695f2bdcbdcd5772ba203c4e1a56686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dc02940581e3fe8e02bbdbcc91f504" id="r_ae1dc02940581e3fe8e02bbdbcc91f504"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#ae1dc02940581e3fe8e02bbdbcc91f504">operator!=</a> (const <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;other) const</td></tr>
<tr class="memdesc:ae1dc02940581e3fe8e02bbdbcc91f504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this buffer different from <code>other</code>?  <br /></td></tr>
<tr class="separator:ae1dc02940581e3fe8e02bbdbcc91f504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d93461c6a6e7b33bafc6f7b9e2c48bb" id="r_a8d93461c6a6e7b33bafc6f7b9e2c48bb"><td class="memTemplParams" colspan="2"><a id="a8d93461c6a6e7b33bafc6f7b9e2c48bb" name="a8d93461c6a6e7b33bafc6f7b9e2c48bb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d93461c6a6e7b33bafc6f7b9e2c48bb"><td class="memTemplItemLeft" align="right" valign="top">std::span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value</b> ()</td></tr>
<tr class="separator:a8d93461c6a6e7b33bafc6f7b9e2c48bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc3dd522556be5c2bfbc8adb96c5012" id="r_a9fc3dd522556be5c2bfbc8adb96c5012"><td class="memTemplParams" colspan="2"><a id="a9fc3dd522556be5c2bfbc8adb96c5012" name="a9fc3dd522556be5c2bfbc8adb96c5012"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fc3dd522556be5c2bfbc8adb96c5012"><td class="memTemplItemLeft" align="right" valign="top">std::span&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value</b> () const</td></tr>
<tr class="separator:a9fc3dd522556be5c2bfbc8adb96c5012"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1a61270d41b7b3c12b74fa06c27a131a" id="r_a1a61270d41b7b3c12b74fa06c27a131a"><td class="memTemplParams" colspan="2"><a id="a1a61270d41b7b3c12b74fa06c27a131a" name="a1a61270d41b7b3c12b74fa06c27a131a"></a>
template&lt;typename TupleType , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:a1a61270d41b7b3c12b74fa06c27a131a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_contiguous_buffer</b> (Visitor &amp;&amp;visitor, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a1a61270d41b7b3c12b74fa06c27a131a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a1a61270d41b7b3c12b74fa06c27a131a" id="r_a1a61270d41b7b3c12b74fa06c27a131a"><td class="memTemplParams" colspan="2">template&lt;typename TupleType , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:a1a61270d41b7b3c12b74fa06c27a131a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a1a61270d41b7b3c12b74fa06c27a131a">visit_contiguous_buffer</a> (Visitor &amp;&amp;visitor, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1a61270d41b7b3c12b74fa06c27a131a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the process of calling a visitor with zero or more <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> objects.  <br /></td></tr>
<tr class="separator:a1a61270d41b7b3c12b74fa06c27a131a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A type-erased buffer of floating-point values. </p>
<p>Conceptually this class type-erases a buffer (i.e. an array) of floating- point types. Think of the buffer more like std::array rather than std::vector. In particular, the size of <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> objects are fixed and can not be changed (aside from assigning a new <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> to them). </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a33ae684e80d7ae56007efd7066f7a087" name="a33ae684e80d7ae56007efd7066f7a087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ae684e80d7ae56007efd7066f7a087">&#9670;&#160;</a></span>holder_pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a33ae684e80d7ae56007efd7066f7a087">wtf::buffer::FloatBuffer::holder_pointer</a> =  typename <a class="el" href="classwtf_1_1buffer_1_1detail___1_1BufferHolder.html#af6da0f90639b3ff4462098c267c5ec6f">holder_type::holder_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pull in types from the holder_type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afc62a8eb534601e52ce5873aae4979c2" name="afc62a8eb534601e52ce5873aae4979c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc62a8eb534601e52ce5873aae4979c2">&#9670;&#160;</a></span>FloatBuffer() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wtf::buffer::FloatBuffer::FloatBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty buffer. </p>
<p>This ctor creates a <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> which contains zero elements and is capable of holding no elements.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad13902e3c35e78c18c35dbcc01e606c3" name="ad13902e3c35e78c18c35dbcc01e606c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13902e3c35e78c18c35dbcc01e606c3">&#9670;&#160;</a></span>FloatBuffer() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::FloatingPoint T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wtf::buffer::FloatBuffer::FloatBuffer </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> from a list of specified values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of floating-point value being held. Must satisfy the concepts::FloatingPoint concept.</td></tr>
  </table>
  </dd>
</dl>
<p>This ctor will copy the elements in <code>buffer</code> into a std::vector and then invoke the std::vector-based ctor to create the <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a>. See that ctor for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The initial values for the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if creating the held buffer fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59eb74acdf2db8afe431a5bf0481f509" name="a59eb74acdf2db8afe431a5bf0481f509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59eb74acdf2db8afe431a5bf0481f509">&#9670;&#160;</a></span>FloatBuffer() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::FloatingPoint T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wtf::buffer::FloatBuffer::FloatBuffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> from a std::vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of floating-point value being held. Must satisfy the concepts::FloatingPoint concept.</td></tr>
  </table>
  </dd>
</dl>
<p>In practice we find that many users store their floating-point data in std::vector objects. This ctor optimizes for this frequent use case by allowing the user to pass in a std::vector. If the user moves the vector into this ctor then no copies of the data will be made (if they do not move it then it will be copied).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer to type-erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if creating the held buffer fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cfc18b2a1d3ff20aca110b8b448e6d8" name="a7cfc18b2a1d3ff20aca110b8b448e6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfc18b2a1d3ff20aca110b8b448e6d8">&#9670;&#160;</a></span>FloatBuffer() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::FPIterator BeginItr, concepts::FPIterator EndItr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">wtf::buffer::FloatBuffer::FloatBuffer </td>
          <td>(</td>
          <td class="paramtype">BeginItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndItr &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> from a range of iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BeginItr</td><td>The type of the begin iterator. Must satisfy the concepts::FPIterator concept. </td></tr>
    <tr><td class="paramname">EndItr</td><td>The type of the end iterator. Must satisfy the concepts::FPIterator concept.</td></tr>
  </table>
  </dd>
</dl>
<p>This ctor will create a <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> by copying the elements in the range. Note that <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> objects own their data, so the data must be copied in. If the user would prefer to avoid the copy they may alias the data using the FloatBufferView class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>The iterator pointing to the beginning of the range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The iterator pointing to one past the end of the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if creating the held buffer fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12aa995db0ed62b437bf81bfae980263" name="a12aa995db0ed62b437bf81bfae980263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12aa995db0ed62b437bf81bfae980263">&#9670;&#160;</a></span>FloatBuffer() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wtf::buffer::FloatBuffer::FloatBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> as a copy of <code>other</code>. </p>
<p>This ctor will initialize *this to hold a deep copy of <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if copying the held buffer fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c763c97ca7ae1bae432255d6436462f" name="a0c763c97ca7ae1bae432255d6436462f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c763c97ca7ae1bae432255d6436462f">&#9670;&#160;</a></span>FloatBuffer() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wtf::buffer::FloatBuffer::FloatBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> by taking the state from <code>other</code>. </p>
<p>This ctor will initialize *this by taking ownership of the buffer held in <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> to move from. After the operation <code>other</code> is in a valid but unspecified state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a164cb24d3bcc20a80761edde8ea90e6e" name="a164cb24d3bcc20a80761edde8ea90e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164cb24d3bcc20a80761edde8ea90e6e">&#9670;&#160;</a></span>as_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wtf::buffer::FloatBuffer::as_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly converts *this into a <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a>. </p>
<p><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> objects are implicitly convertible to <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> objects, so that APIs written in terms of <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> objects can be used with both view and values. However, there are times when the user may want to be explicit about the conversion. This method allows for that.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> aliasing the held buffer, or a null <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> if *this is not holding a buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if creating the <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a002c06fc30fca256a1b280f9e9a0f0ea" name="a002c06fc30fca256a1b280f9e9a0f0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002c06fc30fca256a1b280f9e9a0f0ea">&#9670;&#160;</a></span>as_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto wtf::buffer::FloatBuffer::as_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicitly converts *this into a <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a>. </p>
<p>This method is the same as the non-const version, but returns a read- only <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a>. See the non-const version for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>A const <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> aliasing the held buffer, or a null <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> if *this is not holding a buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if creating the <a class="el" href="classwtf_1_1buffer_1_1BufferView.html" title="A type-erased buffer of floating-point values.">BufferView</a> fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79439d94db5eea1d58d16c5f54669929" name="a79439d94db5eea1d58d16c5f54669929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79439d94db5eea1d58d16c5f54669929">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">view_type wtf::buffer::FloatBuffer::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element with offset <code>index</code>. </p>
<p>This method is used to retrieve an element of the buffer. The returned element aliases the buffer, meaning that you can write to the buffer through the element. While float_cast can be used to ge the address in the buffer (by casting to a reference), users should use <code>contiguous_buffer_cast</code> to get a span if they need to get the pointer (and ensure the underlying memory really is contiguous).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A view to the element at offset <code>index</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>index</code> is not less than <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#af4d452340ab895507bc0d315bafdaeb1" title="Returns the number of elements in the buffer.">size()</a>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a407663baaba19635328c674d5eea104b" name="a407663baaba19635328c674d5eea104b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407663baaba19635328c674d5eea104b">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_view_type wtf::buffer::FloatBuffer::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element with offset <code>index</code>. </p>
<p>This method is the same as the non-const version, but returns a read- only view of the element. See the non-const version for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the element to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const view to the element at offset <code>index</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>index</code> is not less than <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#af4d452340ab895507bc0d315bafdaeb1" title="Returns the number of elements in the buffer.">size()</a>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7282e501eb469c92e94864586fa7262" name="ac7282e501eb469c92e94864586fa7262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7282e501eb469c92e94864586fa7262">&#9670;&#160;</a></span>is_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wtf::buffer::FloatBuffer::is_contiguous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the held buffer store the values contiguously? </p>
<p>Given a pointer to one element in the buffer, if the elements of the buffer are contiguous then pointer arithmetic may be used to access the other elements. If the buffer is not contiguous then the only way to access the elements is through the <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a79439d94db5eea1d58d16c5f54669929" title="Returns the element with offset index.">at()</a> method. Attempting to treat a non-contiguous buffer as contiguous will lead to undefined behavior.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the held buffer is contiguous, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1dc02940581e3fe8e02bbdbcc91f504" name="ae1dc02940581e3fe8e02bbdbcc91f504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1dc02940581e3fe8e02bbdbcc91f504">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wtf::buffer::FloatBuffer::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this buffer different from <code>other</code>? </p>
<p>Two <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> objects are different if they are not value equal. Thus this method simply negates the result of operator==. See that method for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if *this and <code>other</code> are different, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8830755b14fdcea4d0b742be31953569" name="a8830755b14fdcea4d0b742be31953569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8830755b14fdcea4d0b742be31953569">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp; wtf::buffer::FloatBuffer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides the state of *this with a deep copy of <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if copying the held buffer fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade6375aa4f57ea7404ffcb6c8bbe430c" name="ade6375aa4f57ea7404ffcb6c8bbe430c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6375aa4f57ea7404ffcb6c8bbe430c">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp; wtf::buffer::FloatBuffer::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides the state of *this with the state in <code>other</code>. </p>
<p>This operator will override the state of *this by taking ownership of the buffer held in <code>other</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> to move from. After the operation <code>other</code> is in a valid but unspecified state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a695f2bdcbdcd5772ba203c4e1a56686c" name="a695f2bdcbdcd5772ba203c4e1a56686c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695f2bdcbdcd5772ba203c4e1a56686c">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wtf::buffer::FloatBuffer::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html">FloatBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is value equal to <code>other</code>. </p>
<p>Two <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> objects are value equal if they hold the same number of elements, if those elements are of the same type, and if the corresponding elements compare equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if *this and <code>other</code> are value equal, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4d452340ab895507bc0d315bafdaeb1" name="af4d452340ab895507bc0d315bafdaeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d452340ab895507bc0d315bafdaeb1">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type wtf::buffer::FloatBuffer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the buffer. </p>
<p>This method is used to retrieve the number of elements in the buffer. Since the buffer is zero-indexed, valid indices for <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#a79439d94db5eea1d58d16c5f54669929" title="Returns the element with offset index.">at()</a> are in the range [0, <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html#af4d452340ab895507bc0d315bafdaeb1" title="Returns the number of elements in the buffer.">size()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the buffer.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">No-throw</td><td>guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a1a61270d41b7b3c12b74fa06c27a131a" name="a1a61270d41b7b3c12b74fa06c27a131a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a61270d41b7b3c12b74fa06c27a131a">&#9670;&#160;</a></span>visit_contiguous_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TupleType , typename Visitor , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto visit_contiguous_buffer </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the process of calling a visitor with zero or more <a class="el" href="classwtf_1_1buffer_1_1FloatBuffer.html" title="A type-erased buffer of floating-point values.">FloatBuffer</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TupleType</td><td>A std::tuple of floating-point types to try. Must be explicitly provided by the user. </td></tr>
    <tr><td class="paramname">Visitor</td><td>The type of the visitor to call. Must be a callable object capable of accepting <code>std::span&lt;T&gt;</code> objects for each possible T in <code>TupleType</code>. Will be inferred by the compiler. </td></tr>
    <tr><td class="paramname">Args</td><td>The types of the arguments to forward to the visitor. Each is expected to be downcastable to a ContiguousModel holding one of the types in <code>TupleType</code>. Will be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">visitor</td><td>The visitor to call with the unwrapped std::span&lt;T&gt; objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The ContiguousModel objects to unwrap and pass to the visitor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of calling <code>visitor</code> with the unwrapped std::span&lt;T&gt; objects.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if any of the <code>args</code> cannot be downcast to a ContiguousModel holding one of the types in <code>TupleType</code>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>if calling <code>visitor</code> throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/wtf/buffer/<a class="el" href="buffer_2float__buffer_8hpp_source.html">float_buffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
