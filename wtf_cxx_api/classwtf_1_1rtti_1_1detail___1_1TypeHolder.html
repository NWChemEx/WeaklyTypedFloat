<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>wtf: wtf::rtti::detail_::TypeHolder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">wtf<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacewtf.html">wtf</a></li><li class="navelem"><a class="el" href="namespacewtf_1_1rtti.html">rtti</a></li><li class="navelem"><b>detail_</b></li><li class="navelem"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html">TypeHolder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classwtf_1_1rtti_1_1detail___1_1TypeHolder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">wtf::rtti::detail_::TypeHolder Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Defines the interface for interacting with the type-erased type.  
 <a href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="type__holder_8hpp_source.html">type_holder.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for wtf::rtti::detail_::TypeHolder:</div>
<div class="dyncontent">
<div class="center"><img src="classwtf_1_1rtti_1_1detail___1_1TypeHolder__inherit__graph.png" border="0" usemap="#awtf_1_1rtti_1_1detail___1_1TypeHolder_inherit__map" alt="Inheritance graph"/></div>
<map name="awtf_1_1rtti_1_1detail___1_1TypeHolder_inherit__map" id="awtf_1_1rtti_1_1detail___1_1TypeHolder_inherit__map">
<area shape="rect" title="Defines the interface for interacting with the type&#45;erased type." alt="" coords="14,5,135,45"/>
<area shape="rect" href="classwtf_1_1rtti_1_1detail___1_1TypeModel.html" title="Implements TypeHolder for type T." alt="" coords="5,93,144,133"/>
<area shape="poly" title=" " alt="" coords="77,59,77,93,72,93,72,59"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9a696a365bc9f499e77a092b86437509" id="r_a9a696a365bc9f499e77a092b86437509"><td class="memItemLeft" align="right" valign="top"><a id="a9a696a365bc9f499e77a092b86437509" name="a9a696a365bc9f499e77a092b86437509"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>string_type</b> = std::string</td></tr>
<tr class="memdesc:a9a696a365bc9f499e77a092b86437509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for storing the name of the held type. <br /></td></tr>
<tr class="separator:a9a696a365bc9f499e77a092b86437509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463d448cc51d8759bdd5e04fb28b1b65" id="r_a463d448cc51d8759bdd5e04fb28b1b65"><td class="memItemLeft" align="right" valign="top"><a id="a463d448cc51d8759bdd5e04fb28b1b65" name="a463d448cc51d8759bdd5e04fb28b1b65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_string_reference</b> = const <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#a9a696a365bc9f499e77a092b86437509">string_type</a> &amp;</td></tr>
<tr class="memdesc:a463d448cc51d8759bdd5e04fb28b1b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for passing around a read-only string_type without copying. <br /></td></tr>
<tr class="separator:a463d448cc51d8759bdd5e04fb28b1b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52a9d2ee4a3beb511939901420992be" id="r_ae52a9d2ee4a3beb511939901420992be"><td class="memItemLeft" align="right" valign="top"><a id="ae52a9d2ee4a3beb511939901420992be" name="ae52a9d2ee4a3beb511939901420992be"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>holder_pointer</b> = std::shared_ptr&lt; <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html">TypeHolder</a> &gt;</td></tr>
<tr class="memdesc:ae52a9d2ee4a3beb511939901420992be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pointer used to hold <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html" title="Defines the interface for interacting with the type-erased type.">TypeHolder</a> instances. <br /></td></tr>
<tr class="separator:ae52a9d2ee4a3beb511939901420992be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eabad7f2c9298e3071202ad8ad1cb2" id="r_ac5eabad7f2c9298e3071202ad8ad1cb2"><td class="memItemLeft" align="right" valign="top"><a id="ac5eabad7f2c9298e3071202ad8ad1cb2" name="ac5eabad7f2c9298e3071202ad8ad1cb2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>precision_type</b> = std::size_t</td></tr>
<tr class="memdesc:ac5eabad7f2c9298e3071202ad8ad1cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for specifying precision of floating-point types. <br /></td></tr>
<tr class="separator:ac5eabad7f2c9298e3071202ad8ad1cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adbec61bf3df2181b93aeaabd5514ed2b" id="r_adbec61bf3df2181b93aeaabd5514ed2b"><td class="memItemLeft" align="right" valign="top"><a id="adbec61bf3df2181b93aeaabd5514ed2b" name="adbec61bf3df2181b93aeaabd5514ed2b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~TypeHolder</b> ()=default</td></tr>
<tr class="memdesc:adbec61bf3df2181b93aeaabd5514ed2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default virtual destructor. <br /></td></tr>
<tr class="separator:adbec61bf3df2181b93aeaabd5514ed2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52b4056c9f61e373f6cf39ebfcc34a6" id="r_ad52b4056c9f61e373f6cf39ebfcc34a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#ae52a9d2ee4a3beb511939901420992be">holder_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#ad52b4056c9f61e373f6cf39ebfcc34a6">get_model</a> () const</td></tr>
<tr class="memdesc:ad52b4056c9f61e373f6cf39ebfcc34a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the model for the type of *this.  <br /></td></tr>
<tr class="separator:ad52b4056c9f61e373f6cf39ebfcc34a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95420ca9eca67fae28b644a9ad62c55" id="r_ac95420ca9eca67fae28b644a9ad62c55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#a463d448cc51d8759bdd5e04fb28b1b65">const_string_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#ac95420ca9eca67fae28b644a9ad62c55">name</a> () const</td></tr>
<tr class="memdesc:ac95420ca9eca67fae28b644a9ad62c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human-readable name for the type.  <br /></td></tr>
<tr class="separator:ac95420ca9eca67fae28b644a9ad62c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1995f1e2c1d206ff8301dc1ed45d3520" id="r_a1995f1e2c1d206ff8301dc1ed45d3520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#ac5eabad7f2c9298e3071202ad8ad1cb2">precision_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#a1995f1e2c1d206ff8301dc1ed45d3520">precision</a> () const</td></tr>
<tr class="memdesc:a1995f1e2c1d206ff8301dc1ed45d3520"><td class="mdescLeft">&#160;</td><td class="mdescRight">In base 10, the number of significant digits this type can hold.  <br /></td></tr>
<tr class="separator:a1995f1e2c1d206ff8301dc1ed45d3520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d7d8c4ff2e8bac4fc8b2a97b8350df" id="r_ab7d7d8c4ff2e8bac4fc8b2a97b8350df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#ab7d7d8c4ff2e8bac4fc8b2a97b8350df">is_const</a> () const</td></tr>
<tr class="memdesc:ab7d7d8c4ff2e8bac4fc8b2a97b8350df"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the held type is const-qualified and false otherwise.  <br /></td></tr>
<tr class="separator:ab7d7d8c4ff2e8bac4fc8b2a97b8350df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fbe3b350c2539927044556afa60be9" id="r_a39fbe3b350c2539927044556afa60be9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#ae52a9d2ee4a3beb511939901420992be">holder_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#a39fbe3b350c2539927044556afa60be9">make_const</a> () const</td></tr>
<tr class="memdesc:a39fbe3b350c2539927044556afa60be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html" title="Defines the interface for interacting with the type-erased type.">TypeHolder</a> for the const version of the type held by *this.  <br /></td></tr>
<tr class="separator:a39fbe3b350c2539927044556afa60be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5810c53fb5635b8a796601d8c83e21f6" id="r_a5810c53fb5635b8a796601d8c83e21f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#a5810c53fb5635b8a796601d8c83e21f6">are_equal</a> (const <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html">TypeHolder</a> &amp;other) const</td></tr>
<tr class="memdesc:a5810c53fb5635b8a796601d8c83e21f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if *this is polymorphically value equal to <code>other</code>.  <br /></td></tr>
<tr class="separator:a5810c53fb5635b8a796601d8c83e21f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe31e26cfd5941f12e0e3f32f152584" id="r_a3fe31e26cfd5941f12e0e3f32f152584"><td class="memTemplParams" colspan="2">template&lt;typename TypeTuple &gt; </td></tr>
<tr class="memitem:a3fe31e26cfd5941f12e0e3f32f152584"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#a3fe31e26cfd5941f12e0e3f32f152584">is_implicitly_convertible_to</a> (const <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html">TypeHolder</a> &amp;other) const</td></tr>
<tr class="memdesc:a3fe31e26cfd5941f12e0e3f32f152584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the type held by *this can be implicitly converted to the type held by <code>other</code>.  <br /></td></tr>
<tr class="separator:a3fe31e26cfd5941f12e0e3f32f152584"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad93b8aa3d996de893c0b9a0c4183cb5d" id="r_ad93b8aa3d996de893c0b9a0c4183cb5d"><td class="memItemLeft" align="right" valign="top"><a id="ad93b8aa3d996de893c0b9a0c4183cb5d" name="ad93b8aa3d996de893c0b9a0c4183cb5d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>register_model_</b> (const <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html">TypeHolder</a> &amp;model)</td></tr>
<tr class="memdesc:ad93b8aa3d996de893c0b9a0c4183cb5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the process of registering a possibly new <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html" title="Defines the interface for interacting with the type-erased type.">TypeHolder</a>. <br /></td></tr>
<tr class="separator:ad93b8aa3d996de893c0b9a0c4183cb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd2e8bed367be58ad13fa25deca8bc2" id="r_addd2e8bed367be58ad13fa25deca8bc2"><td class="memItemLeft" align="right" valign="top"><a id="addd2e8bed367be58ad13fa25deca8bc2" name="addd2e8bed367be58ad13fa25deca8bc2"></a>
<a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#ae52a9d2ee4a3beb511939901420992be">holder_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_model_</b> (<a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#a463d448cc51d8759bdd5e04fb28b1b65">const_string_reference</a> <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#ac95420ca9eca67fae28b644a9ad62c55">name</a>) const</td></tr>
<tr class="memdesc:addd2e8bed367be58ad13fa25deca8bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the process of looking up a registered <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html" title="Defines the interface for interacting with the type-erased type.">TypeHolder</a> by name. <br /></td></tr>
<tr class="separator:addd2e8bed367be58ad13fa25deca8bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines the interface for interacting with the type-erased type. </p>
<p>This class provides a type-erased interface for interacting with the floating-point type T held by TypeModel&lt;T&gt;. It provides methods for interacting with the type without knowing what T is at compile time. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5810c53fb5635b8a796601d8c83e21f6" name="a5810c53fb5635b8a796601d8c83e21f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5810c53fb5635b8a796601d8c83e21f6">&#9670;&#160;</a></span>are_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wtf::rtti::detail_::TypeHolder::are_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html">TypeHolder</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if *this is polymorphically value equal to <code>other</code>. </p>
<p>Two TypeHolders are considered polymorphically equal if they hold the same qualified type and were declared with the same string name. The logic for this function is implemented by the private are_equal_ method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html" title="Defines the interface for interacting with the type-erased type.">TypeHolder</a> to compare *this to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if *this and <code>other</code> are polymorphically equal and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad52b4056c9f61e373f6cf39ebfcc34a6" name="ad52b4056c9f61e373f6cf39ebfcc34a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52b4056c9f61e373f6cf39ebfcc34a6">&#9670;&#160;</a></span>get_model()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#ae52a9d2ee4a3beb511939901420992be">holder_pointer</a> wtf::rtti::detail_::TypeHolder::get_model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the model for the type of *this. </p>
<p>Types are singletons, so this method will always return the same instance of the model. The model is registered the first time a TypeModel&lt;T&gt; is constructed. The logic for finding the model is in the get_model_ method.</p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html" title="Defines the interface for interacting with the type-erased type.">TypeHolder</a> model for the type of *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if no model is registered for the type of *this. This should be an impossible state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7d7d8c4ff2e8bac4fc8b2a97b8350df" name="ab7d7d8c4ff2e8bac4fc8b2a97b8350df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d7d8c4ff2e8bac4fc8b2a97b8350df">&#9670;&#160;</a></span>is_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wtf::rtti::detail_::TypeHolder::is_const </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the held type is const-qualified and false otherwise. </p>
<p>The derived class uses template meta-programming to determine if the held type is const-qualified. This logic is implemented by the private is_const_ method.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the held type is const-qualified and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fe31e26cfd5941f12e0e3f32f152584" name="a3fe31e26cfd5941f12e0e3f32f152584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe31e26cfd5941f12e0e3f32f152584">&#9670;&#160;</a></span>is_implicitly_convertible_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeTuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool wtf::rtti::detail_::TypeHolder::is_implicitly_convertible_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html">TypeHolder</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the type held by *this can be implicitly converted to the type held by <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TypeTuple</td><td>A std::tuple of types to use for the conversion.</td></tr>
  </table>
  </dd>
</dl>
<p>*this can be implicitly converted to <code>other</code> if, ignoring cv-qualifiers, an object of the type held by *this can be implicitly converted to an object of the type held by <code>other</code>. If *this is const- qualified we additionally enforce that <code>other</code> must be const-qualified.</p>
<dl class="section note"><dt>Note</dt><dd>This method is in general not symmetric.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html" title="Defines the interface for interacting with the type-erased type.">TypeHolder</a> to check conversion to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the type held by *this can be implicitly converted to the type held by <code>other</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39fbe3b350c2539927044556afa60be9" name="a39fbe3b350c2539927044556afa60be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fbe3b350c2539927044556afa60be9">&#9670;&#160;</a></span>make_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#ae52a9d2ee4a3beb511939901420992be">holder_pointer</a> wtf::rtti::detail_::TypeHolder::make_const </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html" title="Defines the interface for interacting with the type-erased type.">TypeHolder</a> for the const version of the type held by *this. </p>
<p>If *this already holds a const-qualified type, this method returns the registered version of *this. Otherwise, it returns the registered version of the const-qualified type. The logic for this function is implemented by the private make_const_ method.</p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a <a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html" title="Defines the interface for interacting with the type-erased type.">TypeHolder</a> holding the const-qualified version of the type held by *this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if no model is registered for the const- version </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac95420ca9eca67fae28b644a9ad62c55" name="ac95420ca9eca67fae28b644a9ad62c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95420ca9eca67fae28b644a9ad62c55">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#a463d448cc51d8759bdd5e04fb28b1b65">const_string_reference</a> wtf::rtti::detail_::TypeHolder::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a human-readable name for the type. </p>
<p>When a TypeModel&lt;T&gt; is constructed, it is given a name to represent the type. This name, plus any cv-qualifiers necessary, are applied to the name returned by this method. The logic for determining the name is in the private name_ method.</p>
<dl class="section return"><dt>Returns</dt><dd>A string representing the name of the held type.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1995f1e2c1d206ff8301dc1ed45d3520" name="a1995f1e2c1d206ff8301dc1ed45d3520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1995f1e2c1d206ff8301dc1ed45d3520">&#9670;&#160;</a></span>precision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwtf_1_1rtti_1_1detail___1_1TypeHolder.html#ac5eabad7f2c9298e3071202ad8ad1cb2">precision_type</a> wtf::rtti::detail_::TypeHolder::precision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In base 10, the number of significant digits this type can hold. </p>
<p>The value returned by this method is determined by the <a class="el" href="structwtf_1_1type__traits_1_1Precision.html" title="Used to determine how many significant figures T has.">type_traits::Precision</a> class. See the documentation for that class for more information. The logic for determining the precision is in the private precision_ method.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of significant digits the held type can represent.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/wtf/rtti/detail_/<a class="el" href="type__holder_8hpp_source.html">type_holder.hpp</a></li>
<li>src/wtf/rtti/detail_/<b>type_holder.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
